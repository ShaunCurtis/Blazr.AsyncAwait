# Async/Await

Async/Await is the fundamental building material of asynchronous operations in modern C#.

It's great blessing is it abstracts the programmer from the nitty gritty of the *Task Processing Library*.   The downside is it's opacity: programmers just use it, most don't understand what's going on beneath the surface.  It's great until you try and make it do something it wasn't designed for. 

To quote Stephen Tomb, one of the authors of Async/Await:

> [It's] both viable and extremely common to utilize the functionality without understanding exactly what’s going on under the covers. You start with a synchronous method ...  sprinkle a few keywords, change a few method names, and you end up with [an] asynchronous method instead. 

There are several very good articles available on the subject, including a very detailed one by Stephen.  Unfortunately most assume a level of knowledge that most programmers don't have.  In this short article I'll attempt to bring that required knowledge down to the level of normal mortals.

**Async**

Async is a compiler directive.  It labels a method as containing one or more awaitable calls to async methods.

**Await**

Defines a method that should be awaited for continuing execution of the code below the await.  Only methods that implement the *awaitable* pattern can be awaited.

## Awaitables and Awaiters

To use `await` the awaited method must be awaitable: it must implement a `GetAwaiter` method, and must return an object that implements the *awaiter* pattern.

```csharp
public struct MyAwaiter : INotifyCompletion
{
    public bool IsCompleted;
    public void OnCompleted(Action continuation);
    public void GetResult();
}
```

You can't await an `Int32`, or can you?

Instead of coding:

```csharp
  await Task.Delay(500);
```

What if you could type:

```csharp
   await 500;
```

Out of context, it's not particularly obvious what it does, but it's certainly succinct.

Yes, you guessed, you can.  All you need is for `Int32` to implement the awaitable pattern and return an awaiter.

It's this simple: 

```csharp
public static TaskAwaiter GetAwaiter(this Int32 milliseconds)
{
    return Task.Delay(milliseconds).GetAwaiter();
}
```

We're calling `Task.Delay(milliseconds)` and returning it's awaiter.

We'll look into awaiters and awaitable in more detail in the *Awaitable* article.  



## Tasks

Tasks are another fundimental building block.  They revolutionised async progrsmming whwn they came along.

`Task` in all it's guises is an implementation of an awaitable.  It returns a `TaskAwaiter` that implements the *awaitable* pattern.

A `Task` is a simple `struct` that represents the state of an asynchronous operation. It's a handle providing a communications channel between the caller and the asynchronous background operation.

It's returned to the caller in one of four states:
1. Completed - probably the most common.  
2. Not Completed - there's a background task running somewhere else that#s in-process.  The Task's result isn't yet set.
3. Faulted - A exception has occured which the task returns.
4. Cancelled - A cancellation token request was successful.  The operation was cancelled.

It's important to understand that the state of the Task is unrelated to the code block that returned it.  The code block has completed.  If the task hasn't conpleted, the continuation [the code block below the await] is captured and will be sceduled to run in the future by the background process when it completes.  We'll look at how it does that shortly.

The asyncronous background operation holds a reference to the task.  When it completes it sets the task's state to Completed and the task's result [if there is one].

You can walk up to any task [regardless of who started it] and attach a continuation.  That continuation will be executed immediately [if the task has already completed] or when the task completes.  Where it runs is based on ConfigureAwait: false - on the executing thread ; true: on the synchronisation context. 

## Async/Await

To demonstrate how opaque *Async/Await* really is, let's look at the code generated by the compiler.

Go to [SharpLab](https://sharplab.io/).  Set the output to *C#* and enter the following code:

```csharp
using System;
using System.Threading.Tasks;

public class C {
    public async Task DoSomeWorkAsync() {
        Console.WriteLine("Starting");
        await DoSomethingAsync();
        Console.WriteLine("Finished");
    }
    
    private Task DoSomethingAsync()
    {
        return Task.Delay(500);
    }
}
```

At first glance, the code is complex and unrecognisable.  Let's break it down.  You now have:

1. A private *Async State Machine* within you parent class
2. A refactored `DoSomeWorkAsync`.
 
`Async` and `await` have disappeared.

Look at the state machine.  The original code block has been split into `n+1` states and code blocks based on awaits.

The state machine provides a public Task object [through the `AsyncTaskMethodBuilder`] which is returned to the caller when the state machine yields control.

The refactored `DoSomeWorkAsync` creates and starts the state machine.

```csharp
    [AsyncStateMachine(typeof(<DoSomeWorkAsync>d__0))]
    [DebuggerStepThrough]
    public Task DoSomeWorkAsync()
    {
        <DoSomeWorkAsync>d__0 stateMachine = new <DoSomeWorkAsync>d__0();
        stateMachine.<>t__builder = AsyncTaskMethodBuilder.Create();
        stateMachine.<>4__this = this;
        stateMachine.<>1__state = -1;
        stateMachine.<>t__builder.Start(ref stateMachine);
        return stateMachine.<>t__builder.Task;
    }
```

`__builder.Start` internally calls `MoveNext`,  the first block runs synchronously to the final async operation [the *await* line] and increments the state. The block either completes or yields control.

If the async operation completes, then execution falls through to the next block, and so on...

If the async operation yields [returns a not complete awaitable such as a Task], the state machine adds a continuation to the awaitable to call `MoveNext` and completes.

When the async operation completes on it's background thread it queues the continuation to run [normally on the synchronisation context].  That "re-enters" the state machine which then executes the next state's code block.

The final state block has no async operation and falls through to the bottom where it sets the state machine's own Task result and it's state to completed.


## An Example

Consider this simple Blazor `Home` page:

```csharp
@page "/"

<PageTitle>Home</PageTitle>

<h1>Hello, world!</h1>

Welcome to your new app.

<div class="mb-3">
    <button class="btn btn-success" @onclick="Clicked">Responsive Click</button>
    <button class="btn btn-danger" @onclick="_Clicked">Unresponsive Click</button>
</div>

<div class="bg-dark text-white m-2 p-2">
    @_message
</div>

@code {
    private string? _message;

    private async Task Clicked()
    {
        _message = $"Processing at {DateTime.Now.ToLongTimeString()}";
        await TaskHelper.DoSomethingAsync();
        _message = $"Completed Processing at {DateTime.Now.ToLongTimeString()}";
    }

    private async Task _Clicked()
    {
        _message = $"Processing at {DateTime.Now.ToLongTimeString()}";
        await TaskHelper.PretendToDoSomethingAsync();
        _message = $"Completed Processing at {DateTime.Now.ToLongTimeString()}";
    }
}
```

*Responsive Click* shows each message in turn.  *Unresponsive Click* shows both messages on completion. 

`TaskHelper` looks like this:

```csharp
public static class TaskHelper
{
    public static Task DoSomethingAsync()
        => Task.Delay(1000);

    public static Task PretendToDoSomethingAsync()
    {
        Thread.Sleep(1000);
        return Task.CompletedTask;
    }
}
```

### The Async State Machine 

When those three lines are compiled *Task Parallel Library* code generators come into action.  Your high level code is recompiled into low level TPL primitive code that builds a async state machine and refactors the caller to use the state machine.

1. `async` is a modifier and `await` is an operator.

1. The state machine is implemented as an object within the parent class - in this case `Home`.  This gives it access to the private methods, properties and variables of `Home`.

2. Each code block between `awaits` is a state.  Think of applying a `split` on `await`: *n* `awaits` produce *n+1* states.

1. The constructor requires a reference to the parent - `_parent`.
 
1. It uses a Task primitive to control the task provided by the state machine.  We'll use  `TaskCompletionSource` in our example.

1. There are class level awaiter variables for each async method called.  In this case `_task1_Awaiter` to assign `DoSomethingAsync` to when we call it.

1. The initial `_state` is `0`.
 
1. The state machine is run by calling `MoveNext`.

Here's the skeleton async state machine for our three liner.

```csharp
class Clicked_StateMachine
{
    enum State { Start, Step1, }
    private readonly Home _parent;

    private readonly TaskCompletionSource _tcs = new();
    private State _state = State.Start;
    private TaskAwaiter _state1_Awaiter = default!;

    public Task Task => _tcs.Task;

    public Clicked_StateMachine(Home parent)
    {
        _parent = parent;
    }

    public void MoveNext()
    { }
}
```

The `MoveNext` detail.  Execution is wrapped in a `try` so we can pass any exceptions to the caller through the `TaskCompletionSource`.

```csharp
public void MoveNext()
{
    try
    {
        //...
    }
    // Something went wrong.  Pass the error to the caller through the completion task
    catch (Exception e)
    {
        _tcs.SetException(e);
    }
}
```

The *State 0* step runs the code up to the first `await`.  It:

1. Sets the message. 
2. Calls `DoSomethingAsync` on the parent and assigns it to `_state1_Task`.  
3. Increments `_state` to the next state.  
4. Checks the state of `_state1_Task`.  
   
 - If the task has yielded control, a continuation is set on the task to call `Execute` when it completes.  
 - If it has an exception or is cancelled then the appropriate state is set on the _taskManager.  
 - If the task is complete, the method falls through into the next state and executes the next step synchronously.  There's no continuation and no yield.

```csharp
    if (_state == 0)
    {
        // The code from the start of the method to the first 'await'.
        {
            _parent._log.AppendLine($"State Machine Processing at {DateTime.Now.ToLongTimeString()}");
        }

        _state1_Task = TaskHelper.DoSomethingAsync();

        _state = 1;

        if (this.ReturnOnTaskStatus(_state1_Task))
            return;
    }
```

The two helper methods look like this.

 - `HandleTaskErrorOrCancellation` handles exceptions and Cancellation.  
 - `ReturnOnTaskStatus` detects if the task ran synchronously and if it did returns `false`.

```csharp
private bool ReturnOnTaskStatus(Task task)
{
    if (task.IsCompleted)
        return false;

    if (!task.IsCompleted)
    {
        task.ContinueWith(_ => Execute());
        return true;
    }

    return HandleTaskErrorOrCancellation(task);
}

private bool HandleTaskErrorOrCancellation(Task task)
{

    if (task.Status == TaskStatus.Canceled)
    {
        _taskManager.SetCanceled();
        return true;
    }

    if (task.Status == TaskStatus.Faulted)
    {
        _taskManager.SetException(task.Exception?.InnerException ?? new Exception("Task just self destructed with no suicide note!"));
        return true;
    }

    return false;
}
```
Step 1 first checks `_state1_Task` for exceptions and cancellation.  If it completed successfully it runs the code to completion [sets the message].  As there's no further awaits it falls out of the bottom to the finalization process.

```csharp
    // Step 1 - the first await block
    if (_state == 1)
    {
        if (this.HandleTaskErrorOrCancellation(_state1_Task))
            return;

        {
            _parent._log.AppendLine($"State Machine Processing completed at {DateTime.Now.ToLongTimeString()}");
        }

        //No more await tasks so fall thro to bottom
    }
```

The finalization process is to set the task manager to complete.

```csharp
// No more steps, job done.  Set the Task to complete and finish.
_taskManager.SetResult();
```

Finally this code is plugged into `Clicked` in `Home`.  Note it's no longer `async` and returns a Task from the state machine to the UI event handler.

```csharp
    private Task Clicked()
    {
        var stateMachine = new Clicked_StateMachine(this);
        stateMachine.Execute();
        return stateMachine.Task;
    }
```

## The Real Thing

The code I've built above isn't the actual code generated by the compiler.  That's a little more complicated because the code above doesn't address certain implementation and performance issues: it's a bit fat and slow.

However it hopefully provides a good insight into what's going on.

An interesting point is that the state machine is compiled as a `class` in debug mode and a `struct` in release mode. 

## References

The primary resources for this article were:

[Sergey Tepliakov's Blog series](https://devblogs.microsoft.com/premier-developer/dissecting-the-async-methods-in-c/)

[Stephen Toub's Blog series](https://devblogs.microsoft.com/pfxteam/await-anything/)

[Stephen Cleary's various airings on the topic such as this one](https://blog.stephencleary.com/2023/11/configureawait-in-net-8.html)

The code example is based on Sergey Tepliakov's code. 